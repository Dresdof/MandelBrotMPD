body Mandelbrot

	import MPDWin;
	
	proc complex(realPart, imaginaryPart) returns c
	{	
		c = new(ComplexRec);
		c^.realPart = realPart;
		c^.imaginaryPart = imaginaryPart;
	}

	proc assignateComplexArray(width, height, beginning, span) returns ca
	{
		int pixelsNumber = width * height;
		ca = new ([pixelsNumber] Complex);
	
		for [i = 1 to pixelsNumber] 
		{
			int x = i % width;
			int y = i / width;
	
			ca^[i] = complex(beginning^.realPart + x * span^.realPart / (width + 1), 
				beginning^.imaginaryPart + y * span^.imaginaryPart / (height + 1));
		}
	}

	procedure absolute (Complex complex) returns real r
	{
		r = sqrt( complex^.realPart**2 + complex^.imaginaryPart**2);
	}

	procedure mandelbrotCalculationS (Complex complexArg) returns int i
	{
		Complex tmpComplex = complex(complexArg^.realPart, complexArg^.imaginaryPart);

		for[n = 0 to maxIter]
		{
			i = n;
			if(absolute(tmpComplex) >= 2.0) {return;}
			
			real realPart = tmpComplex^.realPart**2 - tmpComplex^.imaginaryPart**2 + complexArg^.realPart;
			tmpComplex^.imaginaryPart = (tmpComplex^.realPart * tmpComplex^.imaginaryPart) * 2 + complexArg^.imaginaryPart;
			tmpComplex^.realPart = realPart;
		}
	}
	
	proc mandelbrotSequential(complexArray) returns ia
	{
		int n = ub(complexArray^);
		
		ia = new([n] int);
		
		for [i = 1 to n] {
			ia^[i] = mandelbrotCalculationS(complexArray^[i]);
		}
	}
	
	proc mandelbrotPIF(complexArray) returns ia
	{
		int n = ub(complexArray^);
		
		ia = new([n] int);
		
		co [i = 1 to n]
			ia^[i] = mandelbrotCalculationS(complexArray^[i]);
		oc
	}

	external getenv(string[*]) returns string[2];
	
	procedure getProcNumber() returns int procNumber
	{
		procNumber = 1;
		if (getenv("MPD_PARALLEL") != "") {
			procNumber = int(getenv("MPD_PARALLEL"));
		}
	}

	procedure getLowerBound(int iterator, int n, int procNumber) returns int i
	{
		i = (iterator - 1) * (n / procNumber) + min(n % procNumber, iterator-1) + 1;
	}

	procedure getUpperBound(int iterator, int n, int procNumber) returns int i
	{
		i = getLowerBound(iterator, n, procNumber) + n / procNumber + int(iterator <= n % procNumber) - 1;
	}

	procedure mandelbrotCalculationPIGA (ComplexArray complexArray, ref IntegerArray integerArray, int iterator)
	{
		int procNumber = getProcNumber();
		int n = ub(complexArray^);

		int lowerBound = getLowerBound(iterator, n, procNumber);
		int upperBound = getUpperBound(iterator, n, procNumber);

		for [ i = lowerBound to upperBound ]
		{
			integerArray^[i] = mandelbrotCalculationS(complexArray^[i]);
		}
	}

	proc mandelbrotPIGA(complexArray) returns ia
	{
		int procNumber = getProcNumber();		
		ia = new([ub(complexArray^)] int);

		co [i = 1 to getProcNumber() ]
			mandelbrotCalculationPIGA(complexArray, ia, i);
		oc
	}

	procedure mandelbrotCalculationPIGC (ComplexArray complexArray, ref IntegerArray integerArray, int iterator)
	{
		int procNumber = getProcNumber();
		int n = ub(complexArray^);

		for [ i = iterator + 1 to n by procNumber ]
		{
			integerArray^[i] = mandelbrotCalculationS(complexArray^[i]);
		}
	}

	proc mandelbrotPIGC(complexArray) returns ia
	{
		int procNumber = getProcNumber();		
		ia = new([ub(complexArray^)] int);

		co [i = 0 to getProcNumber() - 1 ]
			mandelbrotCalculationPIGC(complexArray, ia, i);
		oc
	}

	sem mutex = 1;
	int nextTask; 
	int taskSize; 
	int max;

	procedure fa() returns int i
	{
		P(mutex);
		i = nextTask;
		nextTask += taskSize;
		V(mutex);
	}

	procedure getTask(res int lowerBound, res int upperBound) returns bool available
	{
		lowerBound = fa();
		upperBound = min(lowerBound + taskSize - 1, max);

		available = (lowerBound <= max);
	}

	procedure mandelbrotCalculationPST(ComplexArray complexArray, IntegerArray integerArray, int lowerBound, int upperBound)
	{
		for [ i = lowerBound to upperBound ]
		{
			integerArray^[i] = mandelbrotCalculationS(complexArray^[i]);
		}
	}

	procedure executeTask(ComplexArray complexArray, IntegerArray integerArray)
	{
		int lowerBound, upperBound;
		
		while (getTask(lowerBound, upperBound))
		{
			mandelbrotCalculationPST(complexArray, integerArray, lowerBound, upperBound);	
		}
	}

	proc mandelbrotPST(complexArray) returns ia
	{
		nextTask = 1;
		taskSize = 250;
		max = ub(complexArray^);

		ia = new([max] int);

		co [i = 1 to getProcNumber()]
			executeTask(complexArray, ia);
		oc
	} 

	proc draw (iterations, screen, width) 
	{
		int y = 0;
		int oldN = 0;
	
		for [i = 1 to ub(iterations^)] {	

			winPoint pt;
			
			pt.x = i % width;
			pt.y = y;
			
			int n = iterations^[i];
			
			if (n == maxIter) { n = 0; }
			
			if(n != oldN) {
				if(n == 1) { WinSetForeground(screen, "black"); }
				else { WinSetForeground(screen, "blue"); }
			}
			
			if(n > 0) {
				WinDrawPixel(screen, pt);
			}
			
			oldN = n;
			if(pt.x + 1 == width) { y++; }
		}
	}
end
